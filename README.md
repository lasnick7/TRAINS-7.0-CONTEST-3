# TRAINS-7.0-CONTEST-3
[A. Количество единиц](#a)

[B. Миссия джедая Ивана](#b)

[C. Переупорядочивание с XOR](#c)

<h3 id="a">A. Количество единиц</h2>

#### 1 метод:

Cдвигать число вправо пока биты не кончатся и число не превратится в ноль, на каждом шаге смотреть на нулевой (крайний справа) бит с помощью побитового И, в результате операции будет либо 0 либо 1, складывать полученные значения.

Наглядно на примере числа **11001** (25 в десятичной):

	11001	>> 01100	>> 00110	>> 00011	>> 00001	>> 00000
	00001	   00001	   00001	   00001	   00001
	00001	+  00000	+  00000	+  00001	+  00001	= 3

Реализация на Python:
```python
n = int(input())
count = 0
while n != 0:
    count += n & 1      # смотрим на младший бит (либо 0 либо 1)
    n >>= 1             # сдвигаем число вправо
print(count)
```

#### 2 метод.

На каждом шаге сбрасывать наименьший единичный бит числа, считать количество шагов. Сбросить наименьший единичный бит числа можно с помощью констуркции `n & (n - 1)`.

Наглядно на примере числа **11001** (25 в десятичной):

	шаг 1: 11001
	       11000
	       11000	шаг 2: 11000
		               10111
			       10000	шаг 3: 10000
					       01111
					       00000

Реализация на Python:
```python
n = int(input())
count = 0
while n > 0:
    count = count + 1       # считаем шаги
    n = n & (n - 1)         # сбрасываем младший единичный бит
print(count)
```

------------



<h3 id="b">B. Миссия джедая Ивана</h2>

Посмотрим на пример, приведенный в контесте.

|   |  1 | 2  | 3  | 1  |  3 |
| ------------ | ------------ | ------------ | ------------ | ------------ | ------------ |
| **1**  | *0*  | 0 |  1 | 1  |  1 |
| **2** | 0  |   *0*|  2 |  0 |   2|
| **3** |   1|  2 |  *0* |  1 |  3 |
|  **1** | 1  |0   |  1 |  *0* |  1 |
|  **3** | 1  | 2  |  3 |  1 |  *0*|


Переведем числа в матрице в двоичную систему.

|   |  001 | 010  | 111  | 001  |  111 |
| ------------ | ------------ | ------------ | ------------ | ------------ | ------------ |
| **001**  | *000*  | 000 |  001 | 001  |  001 |
| **010** | 000  |   *000*|  010 | 000 |  010|
| **111** |   001|  010 |  *000* |  001 |  111 |
|  **001** |001  |000   |  001 |  *000* |  001 |
|  **111** | 001  | 010  |  111 |  001 |  *000*|

Cледует отметить, что побитовое И числа с самим собой на выходе дает нам то же самое число, т. е. все единицы и все нули сохраняются на своих местах потому что `0&0 = 0` и `1&1 = 1`.

Однако так же известно, что `0&1 = 0` и `1&0 = 0`, из чего мы можем сделать следующий вывод:

Если известно, что в числе, получившемся в результате побитового И каких-либо двух чисел ненулевой бит стоит на k-ой позиции, то значит ненулевой бит так же стоит на k-ой позиции обоих чисел над которыми проводилась операция.

Наглядно:

	*****1**	*****1**	*****0**	*****0**
	*****0**	*****1**	*****0**	*****1**
	*****0**	*****1**	*****0**	*****1**

Благодаря этому свойству мы можем работать со всеми доступными нам результатами побитового И, представленными в матрице. Идея заключается в том, чтобы смотреть, на какой позиции стоит ненулевой бит числе, представленном в матрице и ставить ненулевой бит в ту же позицию в число, которое мы хотим восстановить.

Реализовать это можно с помощью побитового ИЛИ, т.к. если хотя бы в одном из двух чисел, над которыми проводится операция побитового ИЛИ ненулевой бит стоит в k-ой позиции, этот же бит будет стоять в k-ой позиции у результата данной операции.

Наглядно:

	*****1**	*****0**	*****1**
	*****0**	*****1**	*****1**
	*****1**	*****1**	*****1**

Проходом по каждой строке матрицы мы будет восстанавливать каждое число искомого массива, соответствующее текущей строке. Проходом по каждой ячейке в строке, кроме той, чей индекс совпадает с индексом строки (те самые уничтоженные по диагонали ячейки) мы будет "собирать" и ставить ненулевые биты в нужные нам позиции с помощью побитового ИЛИ. Изначально на всех позициях будут нули. В итоге получится так, что все ненулевые биты исходного числа будут стоять на исходных позициях.

Рассмотрим для примера 3-ю строку нашей матрицы:

|   |  j0 |  j1 | j2  | j3  |  j4 |
| ------------ | ------------ | ------------ | ------------ | ------------ | ------------ |
| **??? i2** |   001|  010 |  *000* |  001 |  111 |

Чтобы найти 3-й элемент массива мы сначала поставим 1 в нулевую позицию:
`j0: 000 | 001 = 001`

затем в первую:
`j1: 001 | 010 = 011`

затем пропутим шаг, т.к. `i == j`

затем снова в первую:
`j3: 011 | 010 = 011`

и, наконец, во вторую:
`j4: 011 | 111 = 111`

Выходит, что третий элемент массива равен 111 (3 в десятичной).

Реализация на Python:
```python
N = int(input())
matrix = []
for _ in range(N):
    row = [int(x) for x in input().split()]
    matrix.append(row)
result = []

for i in range(N):
    element = 0
    for j in range(N):
        if i != j:
            element |= matrix[i][j]
    result.append(element)

print(*result)
```

------------


<h3 id="с">C. Переупорядочивание с XOR</h2>

Вначале выведем свойство операции XOR которая понадобится нам в этой задаче:

Выражение `a1 ^ a2 ^ a3 ^ a4 ... ^ an`, в котором ai принимает значение 1 или 0, а n - общее количество операндов, будет принимать значение 0  только тогда, когда количество единиц в нем 0 или кратно 2-м.

Значит, мы можем прийти к следующему выводу:

> *Если перевести числа исходного массива в двоичную запись и составить из них таблицу, то для того, чтобы условие задачи выполнялось, в каждом столбце должно быть четное количество единиц.*

Исходя из этого мы можем сразу же дать ответ `impossible` для таких наборов чисел, у которых суммарное количество единиц - нечетной. 

Посчитаем количество единиц во всех числах, и запомним на будущее количество единиц каждого элемента массива отдельно. Скажем, что количество столбцов в нашей таблице будет равно количеству разрядов самого длинного числа в двоичной записи - а если у других чисел разрядов меньше, то заполним их нулями. (На данном этапе таблица это абстракция)

Пример:

`[7, 10, 11] = [111, 1010, 1011]`

	0111
	1010
	1011

Считаем единицы и проверяем их четность:

```python
n = int(input())                            #--> 3
a = [int(x) for x in input().split()]       #--> [7, 10, 11]

length = max(x.bit_length() for x in a)     #--> 4 cтолбца
ones = [bin(x).count('1') for x in a]       #--> [3, 2, 3]
total_ones = sum(ones)                      #--> 8 единиц, четное

if total_ones % 2 == 1:
    print("impossible")
```

Рассмотрим еще один пример.

[15, 15, 15] = [1111, 1111, 1111]

	1111
	1111
	1111
	итого:
	1111

Количество единиц четное, но ответ все равно будет `impossible`, потому что количество элементов (строк таблицы) - нечетное и мы не можем достичь четного количества единиц для каждого столбца, потому что их больше, чем максимально возможное четное количество единиц для таблицы данного размера.

Такая проблема может возникнуть для массива с нечетным количеством элементов, поэтому можно вывести, что максимально возможное количество единиц будет равно `((n // 2) * 2) умножить на количество стобцов`.

Для простоты понимания с этого момента давайте считать единицы попарно, получается что количество пар единиц не должно превышать `(n // 2) умножить на количество стобцов`.

Если количество пар единиц больше, чем n // 2 - решения не существует:

```python
half_of_ones = total_ones // 2
less_half = n // 2
if half_of_ones > less_half * length:
    print("impossible")
```
Начиная с этого шага представляем что вся наша таблица заполнена нулями. Никаких "перестановок" битов друг с другом мы делать не будем, а заполним таблицу с нуля - общее количество единиц и их количество для каждой строки мы уже знаем, осталось сделать правильно распреление по столбцам.

На следующем шаге нам нужно определить, сколько пар единиц должно стоять в каждом столбце. Делается это очень просто, например в примере выше у нас 8 единиц, следовательно 4 пары, и 4 стобца, значит в каждый столбец мы ставим одну пару.

```python
bit_pares = [half_of_ones // length] * length
```

Однако может оказаться так, что пары не делятся по стобцам равномерно, например:

	11111			14 единиц, 7 пар, 5 стобцов
	11111			по 1 паре на стобец
	10100			??? осталось 2 пары
	11000

В таком случае используем остаток от деления и идею жадного алгоритма, распределяя оставшиеся пары по одной в некоторые столбцы:

```python
for j in range(half_of_ones % length):
	bit_pares[j] += 1
```

Основная работа сделана, нам осталось только раскидать единицы в правильном порядке в таблицу.

Создаем таблицу b:
```python
b = [0] * n
rest = [*ones]  #сколько единиц нам осталось раскидать для каждой строки
```
Единицы будем ставить с помощью побитового ИЛИ, нужный разряд будем находить с помощью сдвига числа 1 влево на этот самый разряд.

Для каждого разряда j будем находить количество единиц (не пар!) в столбце. Присвоим это значение в переменную need.

Можно применить идею жадного алгоритма и отсортировать индексы строк по убыванию количества единиц, которые в них лежат, начиная с самых "забитых единицами".

Для первых need строк (повторюсь, начиная с самых "забитых") ставим единицу в разряд j.

```python
for i in range(length):
    need = 2 * bit_pares[i]
    if need == 0:
        continue

    idxs = sorted(range(n), key=lambda x: rest[x], reverse=True)
    chosen = idxs[:need]
```

На этом этапе может оказаться так, что мы пытаемся поставить единицу в строку, в которую больше ни одна единица не влезет, то есть нарушаем условие «каждая строка не должна получить больше единиц, чем было в оригинале».

Пример:

	1111   	4 столбца, 6 пар единиц, распределение пар:
	0001   	2 2 1 1
	1110   	но число 0001 не позволяет нам такое распределение
	1111

В таком случае задача решения не имеет.

```python
if rest[chosen[-1]] == 0:
	print("impossible")
```

Если все условия соблюдены ставим единицу в нужный разряд и обновляем значение того, сколько еще осталось:
```python
for j in chosen:
    b[j] |= (1 << i)
    rest[j] -= 1
```

Полная реализация на Python:
```python
def rearrange():
    n = int(input())
    a = [int(x) for x in input().split()]

    length = max(x.bit_length() for x in a)
    ones = [bin(x).count('1') for x in a]
    total_ones = sum(ones)

    if total_ones % 2 == 1:
        print("impossible")
        return

    half_of_ones = total_ones // 2
    less_half = n // 2
    if half_of_ones > less_half * length:
        print("impossible")
        return

    bit_pares = [half_of_ones // length] * length
    for j in range(half_of_ones % length):
        bit_pares[j] += 1

    b = [0] * n
    rest = [*ones]

    for i in range(length):
        need = 2 * bit_pares[i]
        if need == 0:
            continue

        idxs = sorted(range(n), key=lambda x: rest[x], reverse=True)
        chosen = idxs[:need]

        if rest[chosen[-1]] == 0:
            print("impossible")
            return

        for j in chosen:
            b[j] |= (1 << i)
            rest[j] -= 1
    print(*b)
rearrange()
```
